### First_version.py - Переборное решение

#### Оценка сложности: О(n! * n^2)

Сложность представляет собой O(n!) как минимум, потому что 
for board in permutations(all_possib_posit) это количество всевозможных перестановок.
Далее идет вложенный цикл for с двумя while в нем, циклы while выполняются ровно n-1 раз в сумме на каждую итерацию. 
То есть сложность этого
куска кода О(n(n-1)) = O(n^2 - n) = O(n^2). Потом идет цикл for, который выполняется n раз.
То есть, не считая самого первого цикла со сложностью n!, получается О(n^2 + n) = O(n^2)
И в итоге получается О(n! * n^2). (у функции all_possible_positions сложность: O(n), но так как это не влияет
на общую сложность, можно не учитывать)


### Second_reqursion_version.py - Рекурсивное решение
#### Оценка сложности: О(n! * n^2)
Оценим отдельно функцию is_safe. В худшем случае она выполняется n раз. В нее вложены два цикла while, 
которые в худшем случае выполняются (n-1) раз. Таким образом, O(n(n-1)) = O(n^2 - n) = O(n^2)
Теперь оценим рекурсивную функцию finding_combinations. Места в первом ряду рассматриваются n раз, во втором 
ряду n-1, в третьем n-2 и так далее. Так как функция is_safe не будет давать возможности размещать
ферзей под другими ферзями по диагонали. Получается, что общая сложность это O(n! * n^2), так как is_safe 
вложена в finding_combinations.


### Third_version.py

#### Оценка сложности: О(1) константная сложность

Так как словарь с посчитанными значениями уже задан и все, что требуется от компьютера, это посмотреть, есть ли
введенный номер в ключах словаря, вывести его, или же вывести, что для такого числа результат не посчитан, сложность
будет константной, так как вне зависимости от величины введенных данных, будет затрачено одинаковое время.