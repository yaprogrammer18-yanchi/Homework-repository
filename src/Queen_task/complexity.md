### First_version.py - Переборное решение

#### Оценка сложности: О(n! * n^2)

Сложность представляет собой O(n!) как минимум, потому что 
for board in permutations(all_possib_posit) это количество всевозможных перестановок.
Далее идет вложенный цикл for с двумя while в нем, циклы while выполняются ровно n-1 раз в сумме на каждую итерацию. 
То есть сложность этого
куска кода О(n(n-1)) = O(n^2 - n) = O(n^2). Потом идет цикл for, который выполняется n раз.
То есть, не считая самого первого цикла со сложностью n!, получается О(n^2 + n) = O(n^2)
И в итоге получается О(n! * n^2).


### Second_reqursion_version.py - Рекурсивное решение
#### Оценка сложности: О(n! * n^2)
Оценим отдельно функцию is_safe. В худшем случае она выполняется n раз. В нее вложены два цикла while, 
которые в худшем случае выполняются (n-1) раз. Таким образом, O(n(n-1)) = O(n^2 - n) = O(n^2)
Теперь оценим рекурсивную функцию finding_combinations. Места в первом ряду рассматриваются n раз, во втором 
ряду - n-1, в третьем n-2 и так далее. Так как функция is_safe не будет давать возможности размещать
ферзей под другими ферзями по диагонали. Получается, что общая сложность это O(n! * n^2), так как is_safe 
вложена в finding_combinations.
